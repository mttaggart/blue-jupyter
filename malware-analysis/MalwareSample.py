import os
import hashlib
import sys
from datetime import datetime
import pyminizip

sys.path.append('../utils/')
from malware import *
from colors import *

# Globals
root_dir = os.getcwd()
dropbox = "dropbox/"
saved_specimens = "saved-specimens/"
now = datetime.now()
date_time = now.strftime("%m-%d-%Y-%H%M%S")


class MalwareSample:

    @staticmethod
    def check_dir(dir):
        """
        Checks if the specified directory exists, if not, it creates it.

        For use with dropbox and saved-specimens dirs, which are important to the functionality of the notebook
        """
        if not os.path.isdir(dir):
            os.mkdir(dir)
            print(info + "Created " + dir)
        else:
            print(info + "Directory '" + dir + "' exists.")

    @staticmethod
    def is_dir_empty(dir):
        """
        Checks if the specified directory is empty

        For use with dropbox, prompts user to drop things in dropbox if it is empty.
        """
        dir_files = os.listdir(dir)
        if len(dir_files) == 0:
            print(recc + "Directory '" + dir + "' is empty.")
            return True

    def __init__(self, sample_name):
        self.sample_name = sample_name.replace("dropbox/", "")
        self.saved_sample_name = ""
        self.sample_path = ""
        self.sha256sum = ""

        self.winapi_imports = []

    @classmethod
    def create_specimen_dirs(cls, sample_name):
        """
        Creates date time stamped specimen dir to hold all triage artifacts
        """
        saved_sample_name = str(date_time) + "_" + sample_name
        sample_dir = saved_specimens + saved_sample_name
        os.system("mkdir " + sample_dir)
        return saved_sample_name

    @classmethod
    def move_and_defang(cls, sample_name, saved_sample_name):
        """
        Moves and renames sample so it is 'defanged' i.e. won't execute if you accidentally double click while
        transferring from your physical host and encrypt your hard drive three days before final papers are due.

        Renames using convention: [Malware].[Name].[OriginalExtension].[DefangExtension]
        """
        prefix = "Malware."
        suffix = ".malz"
        defanged_sample = prefix + sample_name + suffix
        saved_sample = "saved-specimens/" + saved_sample_name + "/" + defanged_sample
        # Copy for dev/troubleshooting, move for prod version
        # os.system("mv dropbox/" + sample + " saved-specimens/" + specimen_dir)
        os.system("cp dropbox/" + sample_name + " " + saved_sample)
        return saved_sample

    @classmethod
    def get_sha256sum(cls, sample_path, saved_sample_name):
        """
        Sha256 sum hash method
        """
        sha256_hash = hashlib.sha256()
        with open(sample_path, "rb") as f:
            for byte_block in iter(lambda: f.read(4096), b""):
                sha256_hash.update(byte_block)
            sha256_value = sha256_hash.hexdigest()
        with open(saved_specimens + saved_sample_name + "/sha256sum.txt", "w") as shafile:
            shafile.write(sha256_value)
            shafile.close()
        return sha256_value

    @classmethod
    def pull_strings(cls, length, saved_sample_name, sample_path):
        """
        Strings with StringSifter
        Ranking extracted strings for relevance in malware analysis
        $ poetry add stringsifter~=2.0
        $ flarestrings -n 8 <my_sample> | rank_strings --scores > outfile [outfile]
        Writes outfile into specimen dir
        """
        sifter_out = "StringSifter-Out.log"
        outfile = saved_specimens + saved_sample_name + "/" + sifter_out
        cmd = "flarestrings -n " + str(length) + " " + sample_path + " | rank_strings --scores > " + outfile
        os.system(cmd)
        print(recc + "Written to outfile: " + outfile)

    @classmethod
    def save_imports(cls, sample_path, saved_sample_name, winapi_imports):
        """
        Takes imports identified by MalAPIReader and saves them to a file: winapi_imports.csv
        """
        malapi_out = "winapi_imports.csv"
        outfile = saved_specimens + saved_sample_name + "/" + malapi_out
        with open(outfile, "w") as f:
            f.write("Import,Details,isMalicious\n")
            for imp, details, is_malicious in winapi_imports:
                f.write(f"{imp},{details},{is_malicious}\n")
        print(recc + "Written to outfile: " + outfile)
        return outfile

    @classmethod
    def zip_and_password_protect(cls, sample_path, saved_sample_name):
        """
        Zips and password protects sample with standard pass: infected
        """
        zip_name = saved_specimens + saved_sample_name + "/" + saved_sample_name + ".zip"
        password = "infected"
        com_lvl = 5
        pyminizip.compress(sample_path, None, zip_name,
                           password, com_lvl)
        with open(saved_specimens + saved_sample_name + "/" + "password.txt", "w") as password_file:
            password_file.write(password)
            password_file.close()
        return zip_name

    @classmethod
    def delete_unzipped_sample(cls, sample_path, zip_name):
        """
        Checks if the sample zip file exists and, if so, deletes the original sample. This is the last thing that
        should be done during triage.
        """
        try:
            if os.path.exists(zip_name):
                os.remove(sample_path)
        except Exception as e:
            print(printError + "Error: file does not exist....")

